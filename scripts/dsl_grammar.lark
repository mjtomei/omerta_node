// Transaction DSL Grammar (PEG-style for Lark)
//
// This grammar defines the complete syntax for the transaction protocol DSL.
// It uses Lark's EBNF-like syntax with PEG semantics (ordered choice).

// =============================================================================
// Top-level structure
// =============================================================================

start: (declaration | COMMENT)*

declaration: transaction_decl
           | imports_decl
           | parameters_block
           | enum_decl
           | message_decl
           | block_decl
           | actor_decl
           | function_decl
           | native_function_decl

// =============================================================================
// Transaction header
// =============================================================================

transaction_decl: "transaction" (NUMBER | IDENTIFIER) STRING STRING?

// =============================================================================
// Imports
// =============================================================================

imports_decl: "imports" import_path
import_path: IDENTIFIER ("/" IDENTIFIER)*

// =============================================================================
// Parameters
// =============================================================================

parameters_block: "parameters" "(" (parameter | COMMENT)* ")"
parameter: IDENTIFIER "=" (NUMBER | IDENTIFIER) IDENTIFIER? STRING?

// =============================================================================
// Enums
// =============================================================================

enum_decl: "enum" IDENTIFIER STRING? "(" enum_value* ")"
enum_value: IDENTIFIER COMMENT?

// =============================================================================
// Messages
// =============================================================================

message_decl: "message" IDENTIFIER "from" IDENTIFIER "to" "[" identifier_list "]" SIGNED? "(" field* ")"
SIGNED: "signed"

// =============================================================================
// Blocks
// =============================================================================

block_decl: "block" IDENTIFIER "by" "[" identifier_list "]" "(" field* ")"

// =============================================================================
// Fields and types
// =============================================================================

field: IDENTIFIER type_expr

type_expr: IDENTIFIER "<" type_expr ("," type_expr)* ">"  -> generic_type
         | IDENTIFIER                                      -> simple_type

identifier_list: IDENTIFIER ("," IDENTIFIER)*

// =============================================================================
// Actors
// =============================================================================

actor_decl: "actor" IDENTIFIER STRING? "(" (actor_body | COMMENT)* ")"

actor_body: store_block
          | trigger_decl
          | state_decl
          | transition

store_block: "store" "(" field* ")"

trigger_decl: "trigger" IDENTIFIER "(" trigger_params? ")" "in" "[" identifier_list "]" STRING?
trigger_params: trigger_param ("," trigger_param)*
trigger_param: IDENTIFIER type_expr

state_decl: "state" IDENTIFIER state_modifier* STRING?
state_modifier: INITIAL | TERMINAL
INITIAL: "initial"
TERMINAL: "terminal"

// =============================================================================
// Transitions
// =============================================================================

// Split into two cases: guarded transitions can have else, unguarded cannot
transition: IDENTIFIER "->" IDENTIFIER transition_trigger guard_clause action_block? else_clause?  -> guarded_transition
          | IDENTIFIER "->" IDENTIFIER transition_trigger action_block?                            -> simple_transition

transition_trigger: "auto"                           -> auto_trigger
                  | "on" IDENTIFIER                  -> named_trigger
                  | "on" "timeout" "(" IDENTIFIER ")" -> timeout_trigger

guard_clause: "when" expr

action_block: "(" action* ")"

else_clause: "else" "->" IDENTIFIER action_block?

// =============================================================================
// Actions
// =============================================================================

action: store_action
      | lookup_action
      | send_action
      | broadcast_action
      | append_action
      | assignment_action

store_action: "store" IDENTIFIER ("," IDENTIFIER)*        -> store_fields
            | "STORE" "(" IDENTIFIER "," expr ")"         -> store_assign

lookup_action: "lookup" IDENTIFIER "=" expr

send_action: "SEND" "(" expr "," IDENTIFIER ")"

broadcast_action: "BROADCAST" "(" IDENTIFIER "," IDENTIFIER ")"

append_action: "APPEND" "(" IDENTIFIER "," expr ")"

assignment_action: IDENTIFIER "=" expr

// =============================================================================
// Functions
// =============================================================================

// Note: We use + to require at least one statement/comment. A function with only comments
// will parse but may be semantically invalid. Truly empty functions are rejected.
function_decl: "function" IDENTIFIER "(" function_params? ")" "->" type_expr "(" COMMENT* stmt (COMMENT | stmt)* ")"
function_params: function_param ("," function_param)*
function_param: IDENTIFIER type_expr

native_function_decl: "native" "function" IDENTIFIER "(" function_params? ")" "->" type_expr STRING

// Generic statement type used in function bodies and loops
// ? prefix makes these inline (transparent) - they pass through their child directly
// NOTE: IF is only supported as a ternary expression, not a statement.
//       Control flow should be expressed through state machine transitions.
?stmt: return_stmt
     | assignment_stmt
     | for_stmt
     | block_stmt

return_stmt: "return"i expr
assignment_stmt: IDENTIFIER "[" expr "]" "=" expr  -> index_assignment
               | IDENTIFIER "=" expr
for_stmt: "FOR"i IDENTIFIER "IN"i expr stmt
block_stmt: "(" stmt+ ")"

// Alias for clarity in function declarations
?function_body: stmt

// =============================================================================
// Expressions
// =============================================================================

// Precedence (lowest to highest):
// 1. or
// 2. and
// 3. not
// 4. comparison (==, !=, <, >, <=, >=)
// 5. additive (+, -)
// 6. multiplicative (*, /)
// 7. unary (-, not)
// 8. postfix (call, field access, index)
// 9. primary (literals, identifiers, grouped)

?expr: lambda_level

// Lambda has lowest precedence - captures everything to the right
?lambda_level: IDENTIFIER "=>" lambda_level               -> lambda_expr
             | or_expr

?or_expr: or_expr "or"i and_expr                         -> binary_or
        | and_expr
?and_expr: and_expr "and"i not_expr                      -> binary_and
         | not_expr
?not_expr: "not"i not_expr                               -> unary_not
         | if_level

// IF expression has lower precedence than comparison, so branches capture full comparisons
?if_level: "IF"i expr "THEN"i if_level "ELSE"i if_level  -> if_expr
         | comparison

?comparison: additive COMP_OP additive                   -> binary_comp
           | additive
COMP_OP: "==" | "!=" | "<=" | ">=" | "<" | ">"

?additive: additive "+" multiplicative                   -> binary_add
         | additive "-" multiplicative                   -> binary_sub
         | multiplicative
?multiplicative: multiplicative "*" unary                -> binary_mul
               | multiplicative "/" unary                -> binary_div
               | unary

?unary: "-" unary                                        -> unary_neg
      | postfix

// Postfix operations: func call, field access, index access
?postfix: postfix "(" args? ")"                          -> func_call
        | postfix "." "[" expr "]"                       -> dynamic_field
        | postfix "." IDENTIFIER                         -> field_access
        | postfix "[" expr "]"                           -> index_access
        | primary

// Struct literals use {} (without colons between field and value)
// Grouped expressions use ()
?primary: "(" expr ")"                                   -> grouped
        | "{" struct_fields? "}"                         -> struct_literal
        | "[" args? "]"                                  -> list_literal
        | IDENTIFIER "." IDENTIFIER                      -> enum_ref
        | NUMBER                                         -> number
        | STRING                                         -> string
        | "true"i                                        -> true_lit
        | "false"i                                       -> false_lit
        | "null"i                                        -> null_lit
        | IDENTIFIER                                     -> identifier

args: expr ("," expr)*

struct_fields: struct_field ("," struct_field)*
struct_field: "..." expr                                 -> spread_field
            | IDENTIFIER expr                            -> named_field

// =============================================================================
// Terminals
// =============================================================================

IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /\-?[0-9]+(\.[0-9]+)?/
STRING: /"[^"\n]*"/
COMMENT: /#[^\n]*/

// Whitespace handling - ignore all whitespace including newlines
// NOTE: We don't ignore COMMENT because we need to capture it in enum values
%import common.WS
%ignore WS

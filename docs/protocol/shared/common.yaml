# Common Types and Functions
# Shared across all protocol transactions
#
# Import in transaction schemas with:
#   imports:
#     - shared/common.yaml

# =============================================================================
# SHARED TYPES
# =============================================================================

types:
  # Chain state at a checkpoint
  ChainState:
    description: "State of a chain at a specific block"
    fields:
      block_hash: { type: hash }
      balance: { type: uint }
      locked_amount: { type: uint }
      trust_score: { type: float }
      block_height: { type: uint }

  # Chain record (last seen block info)
  ChainRecord:
    description: "Information about a chain block"
    fields:
      block_hash: { type: hash }
      timestamp: { type: timestamp }
      block_height: { type: uint }

  # Selection inputs for deterministic witness selection
  SelectionInputs:
    description: "Inputs for deterministic witness selection"
    fields:
      known_peers: { type: "list[peer_id]" }
      trust_scores: { type: "map[peer_id, float]" }
      interaction_counts: { type: "map[peer_id, uint]" }

# =============================================================================
# SHARED FUNCTIONS
# =============================================================================

functions:
  # Compute consensus from a list of verdicts
  # Returns "ACCEPT" if threshold reached, "REJECT" otherwise
  COMPUTE_CONSENSUS:
    description: "Determine consensus direction from verdict list"
    params:
      verdicts: "list[WitnessVerdict]"
      threshold: uint
    returns: string
    body: |
      accept_count = LENGTH(FILTER(verdicts, v => v == ACCEPT))
      IF accept_count >= threshold THEN
        RETURN "ACCEPT"
      ELSE
        RETURN "REJECT"

  # Extract field from list of records
  EXTRACT_FIELD:
    description: "Extract a single field from each record in a list"
    params:
      records: "list[T]"
      field: string
    returns: "list[U]"
    body: |
      RETURN MAP(records, r => r.{field})

  # Count matching items in a list
  COUNT_MATCHING:
    description: "Count items matching a predicate"
    params:
      items: "list[T]"
      predicate: "T => bool"
    returns: uint
    body: |
      RETURN LENGTH(FILTER(items, predicate))

  # Check if list contains item
  CONTAINS:
    description: "Check if list contains an item"
    params:
      items: "list[T]"
      item: T
    returns: bool
    body: |
      RETURN LENGTH(FILTER(items, x => x == item)) > 0

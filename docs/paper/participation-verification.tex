\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}

\geometry{margin=1in}

% Theorem environments
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{property}{Property}

% Code listing style for OMT DSL
\lstdefinelanguage{omt}{
  keywords={transaction, imports, parameters, enum, block, message, actor, function, native, store, trigger, state, by, from, to, signed, in, on, when, auto, else, timeout, initial, terminal},
  keywordstyle=\color{blue}\bfseries,
  keywords=[2]{HASH, SIGN, VERIFY_SIG, SEND, BROADCAST, STORE, APPEND, LOAD, NOW, READ, FILTER, MAP, GET, CONTAINS, LENGTH, IF, THEN, ELSE, AND, OR, NOT, RETURN},
  keywordstyle=[2]\color{purple},
  keywords=[3]{hash, uint, int, float, peer_id, timestamp, bytes, string, bool, list, map, dict, any},
  keywordstyle=[3]\color{teal},
  comment=[l]{\#},
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  morestring=[b]",
  sensitive=true,
}

\lstset{
  language=omt,
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  tabsize=4,
  showstringspaces=false,
}

% Title
\title{Participation Verification System with Distributed Trust:\\A Formal Specification}
\author{Omerta Protocol Team}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
We present a distributed trust system for compute swarm participation verification. Unlike centralized trust authorities, our system computes trust locally from on-chain verifiable data. All consumers pay uniform market rates; trust scores determine how payments split between providers and cryptographic burn. We formalize the protocol using a domain-specific language (OMT) for transaction state machines, enabling rigorous specification and automated verification. The system achieves Sybil resistance through time-locked identity credentials and self-correcting verification loops.
\end{abstract}

\tableofcontents
\newpage

%=============================================================================
\section{Introduction}
%=============================================================================

Distributed compute networks face a fundamental challenge: how to establish trust between anonymous participants without a central authority. Traditional approaches rely on reputation systems managed by trusted third parties, creating single points of failure and censorship vectors.

We propose a participation verification system where:
\begin{itemize}
    \item Trust is \emph{subjective}---computed locally by each participant
    \item Trust is \emph{verifiable}---derived from on-chain facts
    \item Trust is \emph{consequential}---determines payment splits and daily distributions
\end{itemize}

\subsection{Core Principles}

\begin{definition}[Verifiable Fact]
A fact is \emph{verifiable} if any participant can independently confirm it by examining the blockchain. Examples include identity age, transaction history, and burn records.
\end{definition}

\begin{definition}[Subjective Trust]
Trust is \emph{subjective} when computed locally by each participant using their own weighting of verifiable facts and personal experience.
\end{definition}

The key insight underlying our design:

\begin{quote}
\textbf{Identity age is the only unforgeable credential.} You cannot buy time on chain---you can only earn it by existing.
\end{quote}

%=============================================================================
\section{System Model}
%=============================================================================

\subsection{Participants}

The system consists of three participant roles:

\begin{description}
    \item[Consumer] Rents compute resources, pays market rate
    \item[Provider] Supplies compute resources, receives trust-weighted payment
    \item[Witness (Cabal)] Verifies transactions, attests to state, earns fees
\end{description}

\subsection{On-Chain Data Structures}

\subsubsection{Identity Record}

An identity is defined by:
\begin{itemize}
    \item \texttt{identity\_id}: Hash of the public key
    \item \texttt{creation\_block}: Block number when identity first appeared
    \item \texttt{public\_key}: For signature verification
\end{itemize}

Derived data (computed from chain, not stored):
\begin{itemize}
    \item Age = current block $-$ creation block
    \item Transaction count
    \item Trust assertions received
\end{itemize}

\subsubsection{Transaction Record}

A compute transaction records:
\begin{itemize}
    \item Consumer and provider identity IDs
    \item Total amount paid by consumer
    \item Amount received by provider
    \item Amount burned
    \item Resource specification (CPU, memory, GPU)
    \item Duration
    \item Signatures from both parties
\end{itemize}

\subsubsection{Trust Assertion}

A trust assertion is a signed claim:
\begin{itemize}
    \item Asserter ID (who makes the claim)
    \item Subject ID (who the claim is about)
    \item Trust score $\in [0, 1]$
    \item Context (e.g., ``compute\_provider'')
    \item Evidence hashes
    \item Timestamp and signature
\end{itemize}

%=============================================================================
\section{Trust Computation}
%=============================================================================

\subsection{Local Trust Calculation}

Each participant computes trust scores locally using:

\begin{equation}
T_{\text{final}} = w_1 \cdot T_{\text{age}} + w_2 \cdot T_{\text{direct}} + w_3 \cdot T_{\text{derived}}
\end{equation}

where $w_1 + w_2 + w_3 = 1$ (typically $w_1 = 0.2$, $w_2 = 0.4$, $w_3 = 0.4$).

\subsubsection{Age Factor}

\begin{equation}
T_{\text{age}} = \min\left(1, \frac{\text{identity\_age}}{\text{AGE\_MATURITY}}\right)
\end{equation}

where AGE\_MATURITY is typically 180 days.

\subsubsection{Direct Experience}

\begin{equation}
T_{\text{direct}} = \frac{\text{successful\_sessions}}{\text{total\_sessions}}
\end{equation}

\subsubsection{Derived Trust (Meta-Trust)}

For scorer $s$ with meta-trust $M_s$ asserting trust $A_s$ about subject:

\begin{equation}
T_{\text{derived}} = \frac{\sum_s M_s \cdot A_s}{\sum_s M_s}
\end{equation}

\subsection{Payment Split Formula}

Given consumer payment $P$ and provider trust $T$:

\begin{align}
\text{provider\_share} &= 1 - \frac{1}{1 + K \cdot T} \\
\text{provider\_receives} &= P \cdot \text{provider\_share} \\
\text{burned} &= P - \text{provider\_receives}
\end{align}

where $K$ is a network constant controlling the trust-to-payment curve.

%=============================================================================
\section{Transaction Protocol}
%=============================================================================

\subsection{Escrow Lock Transaction}

The escrow lock transaction secures funds before a compute session begins. It involves:

\begin{enumerate}
    \item Consumer sends lock intent to provider
    \item Provider selects witness cabal deterministically
    \item Witnesses verify consumer balance and provider availability
    \item Witnesses multi-sign the lock result
    \item Funds are locked on consumer's chain
\end{enumerate}

\subsection{Cabal Attestation Transaction}

During and after a session, the witness cabal:

\begin{enumerate}
    \item Monitors session liveness via periodic pings
    \item Collects termination requests from either party
    \item Computes final attestation (duration, outcome)
    \item Multi-signs the attestation
    \item Broadcasts to network
\end{enumerate}

\subsection{Settlement Transaction}

Based on the cabal attestation:

\begin{enumerate}
    \item Witnesses compute settlement amounts using burn formula
    \item Provider receives trust-weighted payment
    \item Network burns remainder
    \item Consumer receives refund for unused escrow
\end{enumerate}

%=============================================================================
\section{Security Analysis}
%=============================================================================

\subsection{Sybil Resistance}

Creating a new identity provides no advantage:

\begin{theorem}[Sybil Cost]
The cost of a Sybil attack scales linearly with the number of identities and quadratically with the trust level sought:
\begin{equation}
\text{Cost}(n, T) = n \cdot \text{AGE\_MATURITY} \cdot f(T)
\end{equation}
where $f(T)$ increases superlinearly with target trust $T$.
\end{theorem}

\subsection{Collusion Resistance}

Witness selection uses deterministic randomness seeded by both parties:

\begin{equation}
\text{seed} = H(\text{session\_id} \| \text{provider\_nonce} \| \text{consumer\_nonce})
\end{equation}

Neither party can predict or influence the cabal selection without the other's cooperation.

\subsection{Economic Security}

The cost to corrupt a majority of witnesses exceeds the potential gain from a single fraudulent transaction, given appropriate threshold parameters.

%=============================================================================
\section{Daily Distribution}
%=============================================================================

\subsection{Coin Generation}

A fixed amount is minted daily, decreasing over time:

\begin{center}
\begin{tabular}{cc}
\toprule
Year & Daily Mint (OMC) \\
\midrule
1 & 10,000 \\
2 & 8,000 \\
3 & 6,000 \\
4 & 4,000 \\
5 & 2,000 \\
6+ & 1,000 \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Distribution Formula}

Each participant $i$ with trust $T_i$ receives:

\begin{equation}
\text{share}_i = \text{daily\_mint} \cdot \frac{T_i}{\sum_j T_j}
\end{equation}

\subsection{Incentive Alignment}

\begin{property}[Self-Enforcing Honesty]
Misbehavior reduces trust, which reduces daily distribution share. The rational strategy is honest participation.
\end{property}

%=============================================================================
\section{Implementation}
%=============================================================================

We specify the protocol formally using the Omerta Transaction DSL (OMT), a domain-specific language for state machine specification. The complete grammar and semantics are provided in Appendix~\ref{app:dsl-spec}.

Example transaction definitions are provided in Appendix~\ref{app:examples}.

%=============================================================================
\section{Conclusion}
%=============================================================================

We have presented a distributed trust system that achieves:

\begin{itemize}
    \item \textbf{Decentralization}: No central trust authority
    \item \textbf{Verifiability}: All trust inputs are on-chain facts
    \item \textbf{Sybil Resistance}: Time-locked identity credentials
    \item \textbf{Self-Correction}: Meta-trust tracks scorer accuracy
    \item \textbf{Formal Specification}: Protocol defined in verifiable DSL
\end{itemize}

The system creates economic incentives for honest participation through trust-weighted payment splits and daily distributions, eliminating the need for external enforcement mechanisms.

%=============================================================================
\appendix
%=============================================================================

\section{OMT Language Specification}
\label{app:dsl-spec}

The Omerta Transaction DSL (OMT) is a domain-specific language for specifying distributed transaction protocols as communicating state machines.

\subsection{Lexical Structure}

\subsubsection{Comments}

Single-line comments begin with \texttt{\#} and extend to end of line:

\begin{lstlisting}
# This is a comment
\end{lstlisting}

\subsubsection{Identifiers}

\begin{grammar}
<identifier> ::= <letter> (<letter> | <digit> | `_')*

<letter> ::= `a'..`z' | `A'..`Z'

<digit> ::= `0'..`9'
\end{grammar}

Identifiers are case-sensitive. By convention:
\begin{itemize}
    \item \texttt{UPPER\_CASE}: Constants, enum values, built-in functions
    \item \texttt{CamelCase}: Type names, actor names, message names
    \item \texttt{lower\_case}: Variables, fields, parameters
\end{itemize}

\subsubsection{Keywords}

Reserved keywords:
\begin{center}
\begin{tabular}{llll}
\texttt{transaction} & \texttt{imports} & \texttt{parameters} & \texttt{enum} \\
\texttt{block} & \texttt{message} & \texttt{actor} & \texttt{function} \\
\texttt{store} & \texttt{trigger} & \texttt{state} & \texttt{native} \\
\texttt{by} & \texttt{from} & \texttt{to} & \texttt{signed} \\
\texttt{in} & \texttt{on} & \texttt{when} & \texttt{auto} \\
\texttt{else} & \texttt{timeout} & \texttt{initial} & \texttt{terminal} \\
\end{tabular}
\end{center}

\subsubsection{Literals}

\begin{grammar}
<integer> ::= <digit>+

<float> ::= <digit>+ `.' <digit>+

<string> ::= `"' <char>* `"'

<boolean> ::= `true' | `false'

<null> ::= `null'
\end{grammar}

\subsection{Type System}

\subsubsection{Primitive Types}

\begin{center}
\begin{tabular}{ll}
\toprule
Type & Description \\
\midrule
\texttt{uint} & Unsigned integer \\
\texttt{int} & Signed integer \\
\texttt{float} & Floating-point number \\
\texttt{bool} & Boolean \\
\texttt{string} & UTF-8 string \\
\texttt{bytes} & Byte array \\
\texttt{hash} & 256-bit hash value \\
\texttt{peer\_id} & Peer identifier (hash of public key) \\
\texttt{timestamp} & Unix timestamp \\
\texttt{any} & Dynamic type \\
\texttt{dict} & Key-value mapping \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Compound Types}

\begin{grammar}
<list-type> ::= `list<' <type> `>'

<map-type> ::= `map<' <type> `,' <type> `>'
\end{grammar}

Examples: \texttt{list<peer\_id>}, \texttt{map<string, uint>}

\subsection{Top-Level Declarations}

\subsubsection{Transaction Declaration}

\begin{grammar}
<transaction-decl> ::= `transaction' <integer> <string> <string>?
\end{grammar}

The first string is the transaction name, the optional second is a description.

\begin{lstlisting}
transaction 00 "Escrow Lock" "Lock funds for compute session"
\end{lstlisting}

\subsubsection{Import Declaration}

\begin{grammar}
<import-decl> ::= `imports' <path>
\end{grammar}

Imports definitions from another OMT file:

\begin{lstlisting}
imports shared/common
\end{lstlisting}

\subsubsection{Parameters Block}

\begin{grammar}
<params-block> ::= `parameters' `(' <param-def>* `)'

<param-def> ::= <identifier> `=' <literal> <unit>? <string>?

<unit> ::= `seconds' | `count' | `fraction'
\end{grammar}

\begin{lstlisting}
parameters (
    WITNESS_COUNT = 5 count "Number of witnesses"
    TIMEOUT = 300 seconds "Session timeout"
    THRESHOLD = 0.67 fraction "Consensus threshold"
)
\end{lstlisting}

\subsubsection{Enum Declaration}

\begin{grammar}
<enum-decl> ::= `enum' <identifier> <string>? `(' <identifier>+ `)'
\end{grammar}

\begin{lstlisting}
enum WitnessVerdict "Possible verdicts" (
    ACCEPT
    REJECT
    NEED_MORE_INFO
)
\end{lstlisting}

\subsubsection{Block Declaration}

Blocks represent on-chain records:

\begin{grammar}
<block-decl> ::= `block' <identifier> `by' `[' <identifier>+ `]' `(' <field-def>* `)'

<field-def> ::= <identifier> <type>
\end{grammar}

\begin{lstlisting}
block BALANCE_LOCK by [Consumer, Witness] (
    session_id    hash
    amount        uint
    timestamp     timestamp
)
\end{lstlisting}

\subsubsection{Message Declaration}

Messages are signed communications between actors:

\begin{grammar}
<msg-decl> ::= `message' <identifier> `from' <identifier> `to' `[' <identifier>+ `]' `signed'? `(' <field-def>* `)'
\end{grammar}

\begin{lstlisting}
message LOCK_INTENT from Consumer to [Provider] signed (
    session_id    hash
    amount        uint
    timestamp     timestamp
)
\end{lstlisting}

\subsubsection{Function Declaration}

\begin{grammar}
<func-decl> ::= `function' <identifier> `(' <param-list>? `)' (`->' <type>)? `(' <statement>* `)'

<param-list> ::= <identifier> <type> (`,' <identifier> <type>)*
\end{grammar}

\begin{lstlisting}
function COMPUTE_SHARE(trust float) -> float (
    RETURN 1 - 1 / (1 + K_PAYMENT * trust)
)
\end{lstlisting}

\subsection{Actor Declaration}

Actors are state machines that process messages:

\begin{grammar}
<actor-decl> ::= `actor' <identifier> <string>? `(' <actor-body> `)'

<actor-body> ::= <store-block>? <trigger-def>* <state-def>* <transition-def>*
\end{grammar}

\subsubsection{Store Block}

Local state variables for the actor:

\begin{grammar}
<store-block> ::= `store' `(' <field-def>* `)'
\end{grammar}

\begin{lstlisting}
store (
    session_id    hash
    amount        uint
    witnesses     list<peer_id>
)
\end{lstlisting}

\subsubsection{Trigger Declaration}

External triggers initiate state transitions:

\begin{grammar}
<trigger-def> ::= `trigger' <identifier> `(' <param-list>? `)' `in' `[' <identifier>+ `]' <string>?
\end{grammar}

\begin{lstlisting}
trigger initiate_lock(provider peer_id, amount uint) in [IDLE] "Start lock"
\end{lstlisting}

\subsubsection{State Declaration}

\begin{grammar}
<state-def> ::= `state' <identifier> <modifier>* <string>?

<modifier> ::= `initial' | `terminal'
\end{grammar}

\begin{lstlisting}
state IDLE initial "Waiting for trigger"
state DONE terminal "Transaction complete"
state PROCESSING "Processing request"
\end{lstlisting}

\subsubsection{Transition Declaration}

\begin{grammar}
<transition> ::= <from-state> `->' <to-state> <trigger-clause> <guard-clause>? `(' <action>* `)' <else-clause>?

<trigger-clause> ::= `auto' | `on' <identifier> | `on' `timeout(' <identifier> `)'

<guard-clause> ::= `when' <expression>

<else-clause> ::= `else' `->' <to-state> `(' <action>* `)'
\end{grammar}

\begin{lstlisting}
IDLE -> PROCESSING on initiate_lock when amount > 0 (
    store session_id, amount
    SEND(provider, LOCK_INTENT)
) else -> FAILED (
    STORE(error, "invalid_amount")
)

PROCESSING -> DONE auto (
    APPEND(chain, BALANCE_LOCK)
)

WAITING -> FAILED on timeout(LOCK_TIMEOUT) (
    STORE(error, "timeout")
)
\end{lstlisting}

\subsection{Actions}

Actions are operations performed during transitions:

\begin{grammar}
<action> ::= <store-action>
         \alt <send-action>
         \alt <broadcast-action>
         \alt <append-action>
         \alt <compute-action>

<store-action> ::= `store' <identifier> (`,' <identifier>)*
               \alt `STORE(' <identifier> `,' <expression> `)'

<send-action> ::= `SEND(' <expression> `,' <identifier> `)'

<broadcast-action> ::= `BROADCAST(' <expression> `,' <identifier> `)'

<append-action> ::= `APPEND(' <identifier> `,' <expression> `)'
                \alt `APPEND(' `chain' `,' <identifier> `)'

<compute-action> ::= <identifier> `=' <expression>
\end{grammar}

\subsection{Expressions}

\begin{grammar}
<expression> ::= <literal>
             \alt <identifier>
             \alt <expression> <binop> <expression>
             \alt <unop> <expression>
             \alt <identifier> `(' <expr-list>? `)'
             \alt <expression> `.' <identifier>
             \alt <expression> `[' <expression> `]'
             \alt `IF' <expression> `THEN' <expression> `ELSE' <expression>
             \alt <identifier> `=>' <expression>
             \alt `(' <expression> `)'

<binop> ::= `+' | `-' | `*' | `/' | `==' | `!=' | `<' | `>' | `<=' | `>=' | `AND' | `OR'

<unop> ::= `NOT' | `-'

<expr-list> ::= <expression> (`,' <expression>)*
\end{grammar}

\subsection{Built-in Functions}

\begin{center}
\begin{tabular}{lll}
\toprule
Function & Signature & Description \\
\midrule
\texttt{HASH} & $(\texttt{any}, ...) \to \texttt{hash}$ & Cryptographic hash \\
\texttt{SIGN} & $(\texttt{hash}) \to \texttt{bytes}$ & Sign with actor's key \\
\texttt{VERIFY\_SIG} & $(\texttt{bytes}, \texttt{peer\_id}) \to \texttt{bool}$ & Verify signature \\
\texttt{NOW} & $() \to \texttt{timestamp}$ & Current time \\
\texttt{LENGTH} & $(\texttt{list<T>}) \to \texttt{uint}$ & List length \\
\texttt{FILTER} & $(\texttt{list<T>}, T \to \texttt{bool}) \to \texttt{list<T>}$ & Filter list \\
\texttt{MAP} & $(\texttt{list<T>}, T \to U) \to \texttt{list<U>}$ & Transform list \\
\texttt{GET} & $(\texttt{map<K,V>}, K, V?) \to V$ & Map lookup \\
\texttt{CONTAINS} & $(\texttt{list<T>}, T) \to \texttt{bool}$ & List membership \\
\texttt{LOAD} & $(\texttt{identifier}) \to \texttt{any}$ & Load from store \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantic Constraints}

\begin{enumerate}
    \item Each actor must have exactly one \texttt{initial} state
    \item Each actor should have at least one \texttt{terminal} state
    \item All states must be reachable from the initial state
    \item All referenced types, messages, and states must be defined
    \item Triggers can only fire in their declared \texttt{in} states
    \item The \texttt{message} keyword in expressions refers to the received message
    \item The \texttt{peer\_id} keyword refers to the actor's own identity
\end{enumerate}

\section{Example Transaction}
\label{app:examples}

\begin{lstlisting}[caption={Simplified Escrow Lock Transaction}]
transaction 00 "Escrow Lock" "Lock funds for compute session"

imports shared/common

parameters (
    WITNESS_COUNT = 5 count "Number of witnesses"
    LOCK_TIMEOUT = 300 seconds "Time to complete lock"
    THRESHOLD = 0.67 fraction "Consensus threshold"
)

enum LockStatus (
    ACCEPTED
    REJECTED
)

block BALANCE_LOCK by [Consumer, Witness] (
    session_id       hash
    amount           uint
    timestamp        timestamp
)

message LOCK_INTENT from Consumer to [Provider] signed (
    session_id       hash
    amount           uint
    timestamp        timestamp
)

message LOCK_RESULT from Witness to [Consumer] signed (
    session_id       hash
    status           LockStatus
    signatures       list<bytes>
)

actor Consumer "Party paying for service" (
    store (
        session_id       hash
        amount           uint
        lock_result      LockResult
    )

    trigger initiate_lock(provider peer_id, amount uint) in [IDLE]

    state IDLE initial "Waiting to initiate"
    state SENDING "Sending lock intent"
    state WAITING "Waiting for result"
    state LOCKED terminal "Funds locked"
    state FAILED terminal "Lock failed"

    IDLE -> SENDING on initiate_lock when amount > 0 (
        session_id = HASH(peer_id, provider, NOW())
        store amount
        SEND(provider, LOCK_INTENT)
    )

    SENDING -> WAITING auto ()

    WAITING -> LOCKED on LOCK_RESULT when message.status == LockStatus.ACCEPTED (
        store lock_result
        APPEND(chain, BALANCE_LOCK)
    )

    WAITING -> FAILED on LOCK_RESULT when message.status == LockStatus.REJECTED (
        STORE(error, "rejected")
    )

    WAITING -> FAILED on timeout(LOCK_TIMEOUT) (
        STORE(error, "timeout")
    )
)
\end{lstlisting}

\end{document}

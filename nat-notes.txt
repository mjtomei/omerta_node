Part 2
The special case for per-peer won't work for all per-peer pairs. It will only work when the ip:port doesn't change. So we need to have that only happen when we know what type of per-peer peer they both are. Otherwise we have to stick with relaying all messages.

Part 3
I thought we were managing per-machine endpoints instead of per peer now? Shouldn't all the parameters be recentMachines instead of recentPeers? Please add a note about the peer versus machine distinction near the top of the doc.
3.1
How many peers are included in recentPeers in the pong? How are those peers chosen? Is there variation? Are we using those slots efficiently?
3.3
Let's fix the two gaps. We should prefer first hand but use second-hand if that doesn't work.
3.4
Should be machines instead of peers, same applies to all the subsections.
What information are we spreading after a 60 second absence? I don't think we need to spread the endpoint into again this soon unless the endpoint changed. Maybe 10 minutes makes sense.
3.5
Same comment as above, we don't want to be sending the whole peer list every 60 seconds. But sending a peer list per 10 minutes might be ok. We should only send the changes we have seen in our list since the last time we saw the peer though instead of sending the whole list.
We should also support explicitly requesting the whole peer list in a pong response and this should be enabled for manually fired pings unless the user passes a command line option to disable it.
3.7
This should only be used when there is a public or shared endpoint trying to contact a non-peer endpoint. This should also support the case where both peers need to message each other at the same time because they are restricted but on a fixed ip:port. We don't have to consider this type of restriction in the protocol, we can just always have the coordinator tell both parties to contact each other at the same time instead of only responder -> initiator.
3.9
We don't need any separate logic for direct connection attempts if we have the above changes to the code involved with 3.7.

Part 5
All these gaps seem good to fix


